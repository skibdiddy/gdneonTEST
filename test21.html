<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Geometry Dash Neon - Final Refine</title>
  <style>
    body { box-sizing: border-box; margin: 0; padding: 0; overflow: hidden; font-family: 'Arial Black', Arial, sans-serif; background: #000; }
    #game-container { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
    #game-canvas { width: 100%; height: 100%; display: block; }

    /* MENU STYLES */
    #menu-screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      background: linear-gradient(180deg, #1e90ff 0%, #4169e1 100%);
      z-index: 10;
    }
    #menu-screen.hidden { display: none; }
    .menu-floor { position: absolute; bottom: 0; left: 0; width: 100%; height: 120px; background: #1e3a5f; border-top: 4px solid #00ffff; }
    
    /* EXPLODING ICON */
    .drifting-cube {
      position: absolute; bottom: 130px; width: 50px; height: 50px;
      background: #00ff00; border: 2px solid #fff; z-index: 5; left: -60px;
      cursor: pointer;
    }
    .drifting-cube.animating { animation: driftCube 8s linear infinite, rotateCube 2s linear infinite; }
    @keyframes driftCube { 0% { left: -60px; } 100% { left: 100%; } }
    @keyframes rotateCube { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    .particle {
      position: absolute; width: 8px; height: 8px; background: #00ff00;
      pointer-events: none; z-index: 100;
    }

    #game-title { text-align: center; z-index: 2; animation: titleFloat 3s ease-in-out infinite; }
    .title-line { font-size: 80px; color: #00ff00; text-shadow: 0 0 15px #00ff00; font-weight: 900; line-height: 0.9; }
    @keyframes titleFloat { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }

    #start-button {
      margin-top: 30px; padding: 20px 60px; font-size: 30px; font-weight: bold;
      color: #fff; background: linear-gradient(135deg, #00ffff 0%, #ff00ff 100%);
      border: 3px solid #fff; border-radius: 10px; cursor: pointer; z-index: 20;
    }

    #hud { position: absolute; top: 20px; left: 20px; color: #fff; font-size: 24px; z-index: 5; }
    #game-mode-display { position: absolute; top: 20px; right: 20px; color: #fff; font-size: 20px; font-weight: bold; padding: 8px 15px; background: rgba(0,0,0,0.6); border: 2px solid #00ffff; border-radius: 8px; }
    
    #game-over-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.85); z-index: 100; }
    #game-over-screen.show { display: flex; }
    #restart-button { padding: 15px 40px; font-size: 24px; color: #fff; background: #43e97b; border: none; border-radius: 30px; cursor: pointer; }
  </style>
 </head>
 <body>
  <div id="game-container">
   <canvas id="game-canvas"></canvas>
   
   <div id="menu-screen">
    <div class="menu-floor"></div>
    <div class="drifting-cube animating" id="menu-icon"></div>
    <div id="game-title">
      <div class="title-line">GEOMETRY</div>
      <div class="title-line">DASH</div>
    </div>
    <div style="color: #ff00ff; letter-spacing: 8px; font-weight: bold; margin-top: 10px;">NEON MASTER</div>
    <button id="start-button">PLAY</button>
   </div>

   <div id="hud"><div id="score">Score: 0</div></div>
   <div id="game-mode-display">CUBE</div>

   <div id="game-over-screen">
    <h2 style="font-size: 48px; color: #f5576c;">GAME OVER</h2>
    <p id="final-score" style="color:white; font-size: 20px; margin-bottom: 20px;"></p>
    <button id="restart-button">RETRY</button>
   </div>
  </div>

  <script>
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const menuScreen = document.getElementById('menu-screen');
    const menuIcon = document.getElementById('menu-icon');
    const gameOverScreen = document.getElementById('game-over-screen');
    const startButton = document.getElementById('start-button');
    const restartButton = document.getElementById('restart-button');
    const scoreDisplay = document.getElementById('score');
    const gameModeDisplay = document.getElementById('game-mode-display');

    const GAME_SPEED = 10; 
    const GRAVITY = 0.9;
    const JUMP_FORCE = -16;

    let gameRunning = false;
    let score = 0;
    let gameMode = 'cube';
    let groundY;
    let frameCount = 0;
    let isHoldingJump = false;
    let canTriggerOrb = false; // The fix for "no holding on orbs"
    let isTransitioning = false;
    let animationFrameId;

    const obstacles = [];
    const player = {
      x: 180, y: 0, width: 40, height: 40,
      velocityY: 0, rotation: 0,
      ballFlipped: false, spiderFlipped: false, onSurface: false,
      trail: []
    };

    // --- MENU EXPLOSION LOGIC ---
    menuIcon.addEventListener('click', (e) => {
      const rect = menuIcon.getBoundingClientRect();
      const cx = rect.left + 25;
      const cy = rect.top + 25;
      menuIcon.style.display = 'none';
      
      for(let i=0; i<15; i++) {
        const p = document.createElement('div');
        p.className = 'particle';
        p.style.left = cx + 'px'; p.style.top = cy + 'px';
        document.body.appendChild(p);
        const vx = (Math.random() - 0.5) * 20;
        const vy = (Math.random() - 0.5) * 20;
        let opacity = 1;
        let px = cx, py = cy;
        const animateP = () => {
          px += vx; py += vy; opacity -= 0.02;
          p.style.left = px + 'px'; p.style.top = py + 'px'; p.style.opacity = opacity;
          if(opacity > 0) requestAnimationFrame(animateP);
          else p.remove();
        };
        animateP();
      }
      setTimeout(() => { menuIcon.style.display = 'block'; }, 2000);
    });

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      groundY = canvas.height - 100;
    }
    window.addEventListener('resize', resize);
    resize();

    function startGame() {
      menuScreen.classList.add('hidden');
      gameOverScreen.classList.remove('show');
      gameRunning = true; score = 0; frameCount = 0; gameMode = 'cube';
      gameModeDisplay.textContent = 'CUBE';
      obstacles.length = 0; isTransitioning = false;
      player.y = groundY - player.height;
      player.velocityY = 0; player.rotation = 0; player.trail = [];
      player.ballFlipped = false; player.spiderFlipped = false;
      if (animationFrameId) cancelAnimationFrame(animationFrameId);
      animationFrameId = requestAnimationFrame(loop);
    }

    function spawnObstacle() {
      if (isTransitioning) return;
      const x = canvas.width + 100;
      const rand = Math.random();

      if (gameMode === 'cube') {
        if (rand < 0.4) { // Orb + Stacked Tower
          obstacles.push({ x: x - 80, y: groundY - 140, w: 35, h: 35, type: 'orb' });
          obstacles.push({ x, y: groundY - 40, w: 40, h: 40, type: 'block' });
          obstacles.push({ x, y: groundY - 80, w: 40, h: 40, type: 'block' });
          obstacles.push({ x, y: groundY - 120, w: 40, h: 40, type: 'spike' });
        } else {
          obstacles.push({ x, y: groundY - 45, w: 35, h: 45, type: 'spike' });
        }
      } else if (gameMode === 'ball') {
        // Spaced out poles and spikes
        if (rand < 0.5) {
          obstacles.push({ x, y: groundY - 50, w: 30, h: 50, type: 'spike' });
          obstacles.push({ x: x + 250, y: 0, w: 30, h: 50, type: 'spike', flipped: true });
        } else {
          obstacles.push({ x, y: groundY - 80, w: 40, h: 80, type: 'block' });
          obstacles.push({ x: x + 300, y: 0, w: 40, h: 80, type: 'block' });
        }
      } else if (gameMode === 'spider') {
        // Clean, possible teleport corridor
        obstacles.push({ x, y: groundY - 80, w: 40, h: 80, type: 'block' });
        obstacles.push({ x: x + 200, y: 0, w: 40, h: 80, type: 'block' });
      } else if (gameMode === 'wave' || gameMode === 'ship') {
        const gap = 240; const h = 100 + Math.random() * 200;
        obstacles.push({ x, y: 0, w: 40, h: h, type: 'block' });
        obstacles.push({ x, y: h + gap, w: 40, h: groundY - (h + gap), type: 'block' });
      }
    }

    function loop() {
      if (!gameRunning) return;
      frameCount++;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // BG & Ground
      ctx.fillStyle = '#101025'; ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#1e3a5f'; ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
      ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 3; ctx.strokeRect(0, groundY, canvas.width, 2);

      // Physics
      let wasOnSurface = player.onSurface; player.onSurface = false;
      if (gameMode === 'cube') {
        player.velocityY += GRAVITY; player.y += player.velocityY;
        if (player.y >= groundY - player.height) { player.y = groundY - player.height; player.velocityY = 0; player.onSurface = true; player.rotation = Math.round(player.rotation / (Math.PI/2)) * (Math.PI/2); }
        else { player.rotation += 0.18; }
      } else if (gameMode === 'ball') {
        player.velocityY = player.ballFlipped ? -16 : 16; player.y += player.velocityY;
        if (player.y >= groundY - player.height || player.y <= 0) { player.y = (player.y <= 0) ? 0 : groundY - player.height; player.onSurface = true; }
        player.rotation += 0.4;
      } else if (gameMode === 'spider') {
        player.y = player.spiderFlipped ? 0 : groundY - player.height; player.onSurface = true;
      } else if (gameMode === 'wave') {
        player.velocityY = isHoldingJump ? -10 : 10; player.y += player.velocityY;
        player.rotation = isHoldingJump ? -Math.PI/4 : Math.PI/4;
        if (player.y < 0 || player.y > groundY - player.height) gameOver();
      } else if (gameMode === 'ship') {
        player.velocityY += isHoldingJump ? -1.3 : 1.0; player.velocityY = Math.max(-12, Math.min(12, player.velocityY));
        player.y += player.velocityY; player.rotation = player.velocityY * 0.1;
        if (player.y < 0 || player.y > groundY - player.height) player.y = (player.y < 0) ? 0 : groundY - player.height;
      }

      // Land & Jump holding logic
      if (player.onSurface && !wasOnSurface) {
        if (isHoldingJump && gameMode === 'cube') { player.velocityY = JUMP_FORCE; player.onSurface = false; }
      }

      if (frameCount % 80 === 0) spawnObstacle();
      if (frameCount % 800 === 0 && !isTransitioning) {
        isTransitioning = true;
        const next = ['ship', 'ball', 'cube', 'spider', 'wave'].filter(m => m !== gameMode)[Math.floor(Math.random() * 4)];
        obstacles.push({ x: canvas.width + 100, y: 0, w: 100, h: groundY, type: 'portal', to: next });
      }

      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i]; o.x -= GAME_SPEED;
        
        if (o.type === 'portal') {
          ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 5; ctx.strokeRect(o.x, 0, o.w, groundY);
          ctx.fillStyle = '#fff'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'center';
          ctx.fillText(o.to.toUpperCase(), o.x + 50, groundY/2);
        } else if (o.type === 'orb') {
          ctx.fillStyle = '#ffff00'; ctx.beginPath(); ctx.arc(o.x+17, o.y+17, 17, 0, Math.PI*2); ctx.fill();
        } else if (o.type === 'spike') {
          ctx.fillStyle = '#ff4d4d'; ctx.beginPath();
          if (o.flipped) { ctx.moveTo(o.x, 0); ctx.lineTo(o.x+o.w, 0); ctx.lineTo(o.x+o.w/2, o.h); }
          else { ctx.moveTo(o.x, o.y+o.h); ctx.lineTo(o.x+o.w, o.y+o.h); ctx.lineTo(o.x+o.w/2, o.y); }
          ctx.fill();
        } else { ctx.fillStyle = '#f093fb'; ctx.fillRect(o.x, o.y, o.w, o.h); }

        // Collision Check
        if (player.x < o.x + o.w && player.x + player.width > o.x && player.y < o.y + o.h && player.y + player.height > o.y) {
          if (o.type === 'portal') { gameMode = o.to; gameModeDisplay.textContent = gameMode.toUpperCase(); obstacles.splice(i, 1); isTransitioning = false; }
          else if (o.type === 'orb') {
            if (canTriggerOrb) { player.velocityY = JUMP_FORCE; canTriggerOrb = false; } // Trigger only once per click
          } else if (o.type === 'block') {
            if (gameMode !== 'wave' && player.velocityY >= 0 && player.y + player.height < o.y + 25) { player.y = o.y - player.height; player.velocityY = 0; player.onSurface = true; }
            else gameOver();
          } else gameOver();
        }
        if (o.x < -200) { obstacles.splice(i, 1); score += 10; }
      }

      // Draw Player
      ctx.save(); ctx.translate(player.x + 20, player.y + 20); ctx.rotate(player.rotation);
      if (gameMode === 'spider' && player.spiderFlipped) ctx.scale(1, -1);
      ctx.fillStyle = '#43e97b'; ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
      
      if (gameMode === 'spider') {
        ctx.fillRect(-20, -10, 40, 20);
        ctx.beginPath(); // Spider Legs
        ctx.moveTo(-15, -10); ctx.lineTo(-25, -20); ctx.moveTo(15, -10); ctx.lineTo(25, -20);
        ctx.moveTo(-15, 10); ctx.lineTo(-25, 20); ctx.moveTo(15, 10); ctx.lineTo(25, 20);
        ctx.stroke();
      } else if (gameMode === 'ball') {
        ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-20, 0); ctx.lineTo(20, 0); ctx.stroke();
      } else if (gameMode === 'wave') {
        ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(-15, -15); ctx.lineTo(-15, 15); ctx.closePath(); ctx.fill(); ctx.stroke();
      } else if (gameMode === 'ship') {
        ctx.beginPath(); ctx.ellipse(0, 0, 25, 15, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      } else {
        ctx.fillRect(-20, -20, 40, 40); ctx.strokeRect(-20, -20, 40, 40);
      }
      ctx.restore();

      scoreDisplay.textContent = `Score: ${score}`;
      animationFrameId = requestAnimationFrame(loop);
    }

    function gameOver() { gameRunning = false; gameOverScreen.classList.add('show'); document.getElementById('final-score').textContent = `FINAL SCORE: ${score}`; }

    const setInput = (val) => {
      if (val && !gameRunning && gameOverScreen.classList.contains('show')) startGame();
      
      if (val && !isHoldingJump) { // Start of a click
        canTriggerOrb = true; 
        if (gameMode === 'ball' && player.onSurface) player.ballFlipped = !player.ballFlipped;
        else if (gameMode === 'spider' && player.onSurface) player.spiderFlipped = !player.spiderFlipped;
        else if (gameMode === 'cube' && player.onSurface) { player.velocityY = JUMP_FORCE; player.onSurface = false; }
      }
      
      isHoldingJump = val;
      if (!val) canTriggerOrb = false; // Reset orb trigger on release
    };

    window.addEventListener('keydown', (e) => (e.code==='Space'||e.code==='ArrowUp') && setInput(true));
    window.addEventListener('keyup', (e) => (e.code==='Space'||e.code==='ArrowUp') && setInput(false));
    canvas.addEventListener('mousedown', () => setInput(true));
    canvas.addEventListener('mouseup', () => setInput(false));
    startButton.addEventListener('click', startGame);
    restartButton.addEventListener('click', startGame);
  </script>
 </body>
</html>
