<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Geometry Dash Neon - FIXED</title>
  <script src="/_sdk/element_sdk.js"></script>
  <style>
    body { box-sizing: border-box; margin: 0; padding: 0; overflow: hidden; font-family: 'Arial Black', Arial, sans-serif; background: #000; }
    html, body, #game-container { height: 100%; width: 100%; }
    #game-container { position: relative; background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1e 100%); overflow: hidden; }
    #game-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    #menu-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: linear-gradient(180deg, #1e90ff 0%, #4169e1 100%); z-index: 10; }
    #menu-screen.hidden { display: none; }
    .title-line { font-size: 80px; color: #00ff00; text-shadow: 0 0 20px #00ff00; font-weight: 900; line-height: 1; text-align: center; }
    #start-button { padding: 20px 60px; font-size: 30px; font-weight: bold; color: #fff; background: linear-gradient(135deg, #00ffff 0%, #ff00ff 100%); border: 3px solid #00ffff; border-radius: 10px; cursor: pointer; margin-top: 20px; }
    #hud { position: absolute; top: 20px; left: 20px; color: #fff; font-size: 24px; z-index: 5; pointer-events: none; }
    #game-mode-display { position: absolute; top: 20px; right: 20px; color: #fff; font-size: 24px; font-weight: bold; padding: 10px 20px; background: rgba(0, 0, 0, 0.5); border-radius: 10px; border: 2px solid #00ffff; }
    #game-over-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.85); z-index: 100; }
    #game-over-screen.show { display: flex; }
    #restart-button { padding: 15px 40px; font-size: 24px; color: #fff; background: #43e97b; border: none; border-radius: 40px; cursor: pointer; margin-top: 20px; }
  </style>
 </head>
 <body>
  <div id="game-container">
   <canvas id="game-canvas"></canvas>
   <div id="menu-screen">
    <div class="title-line">GEOMETRY</div>
    <div class="title-line">DASH</div>
    <button id="start-button">PLAY</button>
   </div>
   <div id="hud"><div id="score">Score: 0</div></div>
   <div id="game-mode-display">CUBE</div>
   <div id="game-over-screen">
    <h2 style="font-size: 60px; color: #f5576c;">Game Over!</h2>
    <p id="final-score" style="color:white; font-size: 24px;">Score: 0</p>
    <p style="color:#aaa;">Press SPACE to Respawn</p>
    <button id="restart-button">Play Again</button>
   </div>
  </div>

  <script>
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const menuScreen = document.getElementById('menu-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const startButton = document.getElementById('start-button');
    const restartButton = document.getElementById('restart-button');
    const scoreDisplay = document.getElementById('score');
    const modeDisplay = document.getElementById('game-mode-display');

    let gameRunning = false, score = 0, gameMode = 'cube', groundY, frameCount = 0, isHoldingJump = false, obstacles = [];
    const player = { x: 150, y: 0, w: 40, h: 40, vy: 0, rot: 0, jumping: false };

    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; groundY = canvas.height - 100; }
    window.addEventListener('resize', resize); resize();

    function startGame() {
      menuScreen.classList.add('hidden'); gameOverScreen.classList.remove('show');
      gameRunning = true; score = 0; frameCount = 0; gameMode = 'cube';
      modeDisplay.textContent = 'CUBE'; obstacles = [];
      player.y = groundY - player.h; player.vy = 0; player.rot = 0;
      requestAnimationFrame(loop);
    }

    function spawn() {
      const x = canvas.width + 100;
      if (gameMode === 'cube') {
        const r = Math.random();
        if (r < 0.3) { // 2 Blocks + 1 Spike Tower
          obstacles.push({ x, y: groundY - 40, w: 40, h: 40, type: 'block' });
          obstacles.push({ x, y: groundY - 80, w: 40, h: 40, type: 'block' });
          obstacles.push({ x, y: groundY - 120, w: 40, h: 40, type: 'spike' });
          obstacles.push({ x: x - 10, y: groundY - 180, w: 30, h: 30, type: 'orb', active: true });
        } else if (r < 0.6) {
          obstacles.push({ x, y: groundY - 50, w: 30, h: 50, type: 'spike' });
        } else {
          obstacles.push({ x, y: groundY - 40, w: 40, h: 40, type: 'block' });
        }
      } else { // Ship Mode
        const gap = 150 + Math.random() * (groundY - 350);
        obstacles.push({ x, y: 0, w: 60, h: gap, type: 'block' });
        obstacles.push({ x, y: gap + 200, w: 60, h: groundY - (gap + 200), type: 'block' });
      }
    }

    function loop() {
      if (!gameRunning) return;
      frameCount++; ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#1a1a2e'; ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#2c5aa0'; ctx.fillRect(0, groundY, canvas.width, 100);
      ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 4; ctx.strokeRect(-10, groundY, canvas.width+20, 5);

      if (gameMode === 'cube') {
        player.vy += 0.8; player.y += player.vy;
        if (player.y >= groundY - player.h) { player.y = groundY - player.h; player.vy = 0; player.jumping = false; player.rot = 0; }
        else player.rot += 0.15;
      } else {
        player.vy += isHoldingJump ? -0.8 : 0.8; player.vy = Math.max(-8, Math.min(8, player.vy));
        player.y += player.vy; player.y = Math.max(0, Math.min(groundY - player.h, player.y));
        player.rot = player.vy * 0.1;
      }

      if (frameCount % 80 === 0) spawn();
      if (frameCount % 600 === 0) {
        const next = gameMode === 'cube' ? 'ship' : 'cube';
        obstacles.push({ x: canvas.width + 100, y: 0, w: 80, h: groundY, type: 'portal', to: next });
      }

      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i]; o.x -= 9;
        if (o.type === 'portal') { ctx.fillStyle = 'rgba(255,0,255,0.5)'; ctx.fillRect(o.x, 0, o.w, groundY); }
        else if (o.type === 'orb') { if(o.active) { ctx.fillStyle = '#ff0'; ctx.beginPath(); ctx.arc(o.x+15, o.y+15, 15, 0, 7); ctx.fill(); } }
        else if (o.type === 'spike') { ctx.fillStyle = '#ff4d4d'; ctx.beginPath(); ctx.moveTo(o.x, o.y+o.h); ctx.lineTo(o.x+o.w, o.y+o.h); ctx.lineTo(o.x+o.w/2, o.y); ctx.fill(); }
        else { ctx.fillStyle = '#f093fb'; ctx.fillRect(o.x, o.y, o.w, o.h); ctx.strokeRect(o.x, o.y, o.w, o.h); }

        if (player.x < o.x + o.w && player.x + player.w > o.x && player.y < o.y + o.h && player.y + player.h > o.y) {
          if (o.type === 'portal') { gameMode = o.to; modeDisplay.textContent = gameMode.toUpperCase(); obstacles = []; }
          else if (o.type === 'orb' && o.active) { player.vy = -15; o.active = false; }
          else if (o.type === 'block' && player.vy >= 0 && player.y + player.h < o.y + 20) { player.y = o.y - player.h; player.vy = 0; player.jumping = false; }
          else gameOver();
        }
        if (o.x < -100) { obstacles.splice(i, 1); score += 10; }
      }

      ctx.save(); ctx.translate(player.x+20, player.y+20); ctx.rotate(player.rot);
      ctx.fillStyle = '#43e97b'; ctx.strokeStyle = '#000'; ctx.fillRect(-20, -20, 40, 40); ctx.strokeRect(-20, -20, 40, 40);
      ctx.restore();
      scoreDisplay.textContent = `Score: ${score}`;
      requestAnimationFrame(loop);
    }

    function gameOver() { gameRunning = false; gameOverScreen.classList.add('show'); document.getElementById('final-score').textContent = `Score: ${score}`; }

    const handleInput = (down) => {
      if (down && !gameRunning && gameOverScreen.classList.contains('show')) { startGame(); return; }
      if (down && gameMode === 'cube' && !player.jumping) { player.vy = -15; player.jumping = true; }
      isHoldingJump = down;
    };

    window.addEventListener('keydown', (e) => { if (e.code === 'Space' || e.code === 'ArrowUp') handleInput(true); });
    window.addEventListener('keyup', (e) => { if (e.code === 'Space' || e.code === 'ArrowUp') handleInput(false); });
    canvas.addEventListener('mousedown', () => handleInput(true));
    canvas.addEventListener('mouseup', () => handleInput(false));
    startButton.addEventListener('click', startGame);
    restartButton.addEventListener('click', startGame);
  </script>
 </body>
</html>
