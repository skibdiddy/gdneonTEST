<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Geometry Dash Neon BETA</title>
  <script src="/_sdk/element_sdk.js"></script>
  <style>
    body {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: 'Arial Black', Arial, sans-serif;
    }

    html, body, #game-container { height: 100%; width: 100%; }

    #game-container {
      position: relative;
      background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1e 100%);
      overflow: hidden;
    }

    #game-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }

    #menu-screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      background: linear-gradient(180deg, #1e90ff 0%, #4169e1 100%);
      z-index: 10; overflow: hidden;
    }

    #menu-screen.hidden { display: none; }

    .menu-floor {
      position: absolute; bottom: 0; left: 0; width: 100%; height: 120px;
      background: linear-gradient(180deg, #2c5aa0 0%, #1e3a5f 100%);
      border-top: 4px solid #00ffff;
    }

    #game-title { 
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      z-index: 2; animation: titleFloat 3s ease-in-out infinite; 
    }
    
    .title-line { 
      font-size: 96px; color: #00ff00; text-shadow: 0 0 20px #00ff00; 
      font-weight: 900; line-height: 1; text-align: center;
    }

    @keyframes titleFloat { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }

    #start-button {
      padding: 20px 80px; font-size: 36px; font-weight: bold; color: #fff;
      background: linear-gradient(135deg, #00ffff 0%, #ff00ff 100%);
      border: 3px solid #00ffff; border-radius: 10px; cursor: pointer;
      margin-top: 40px;
    }

    #hud { position: absolute; top: 20px; left: 20px; color: #fff; font-size: 24px; z-index: 5; }
    #game-mode-display { position: absolute; top: 20px; right: 20px; color: #fff; font-size: 24px; font-weight: bold; padding: 10px 20px; background: rgba(0, 0, 0, 0.5); border-radius: 10px; border: 2px solid #00ffff; }
    
    #game-over-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.85); z-index: 100; }
    #game-over-screen.show { display: flex; }
    #restart-button { padding: 16px 48px; font-size: 28px; color: #fff; background: #43e97b; border: none; border-radius: 40px; cursor: pointer; }
  </style>
 </head>
 <body>
  <div id="game-container">
   <canvas id="game-canvas"></canvas>
   
   <div id="menu-screen">
    <div id="game-title">
     <div class="title-line">GEOMETRY</div>
     <div class="title-line">DASH</div>
    </div>
    <button id="start-button">PLAY</button>
   </div>

   <div id="hud">
    <div id="score">Score: 0</div>
   </div>
   <div id="game-mode-display">CUBE</div>
   
   <div id="game-over-screen">
    <h2 style="font-size: 64px; color: #f5576c;">Game Over!</h2>
    <p id="final-score" style="color:white; font-size: 24px; margin-bottom: 20px;">Final Score: 0</p>
    <button id="restart-button">Play Again</button>
   </div>
  </div>

  <script>
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const menuScreen = document.getElementById('menu-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const startButton = document.getElementById('start-button');
    const restartButton = document.getElementById('restart-button');
    const scoreDisplay = document.getElementById('score');
    const gameModeDisplay = document.getElementById('game-mode-display');

    let gameRunning = false;
    let score = 0;
    let gameMode = 'cube';
    let groundY;
    let frameCount = 0;
    let isHoldingJump = false;
    let gameSpeed = 9;
    const obstacles = [];

    const player = {
      x: 150, y: 0, width: 40, height: 40,
      velocityY: 0, rotation: 0, jumping: false
    };

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      groundY = canvas.height - 100;
    }
    window.addEventListener('resize', resize);
    resize();

    function startGame() {
      menuScreen.classList.add('hidden');
      gameOverScreen.classList.remove('show');
      gameRunning = true;
      score = 0; frameCount = 0; gameMode = 'cube';
      gameModeDisplay.textContent = 'CUBE';
      obstacles.length = 0;
      player.y = groundY - player.height;
      player.velocityY = 0;
      requestAnimationFrame(loop);
    }

    function spawnObstacle() {
      const x = canvas.width + 100;
      const r = Math.random();

      // IMPORTANT: Every obstacle now ensures a clear path for mode transitions
      if (gameMode === 'cube' || gameMode === 'ball') {
        if (r < 0.5) {
          obstacles.push({ x, y: groundY - 50, w: 30, h: 50, type: 'spike' });
        } else {
          obstacles.push({ x, y: groundY - 40, w: 40, h: 40, type: 'block' });
        }
      } else {
        // Ship/Wave obstacles
        const gapY = 150 + Math.random() * (groundY - 350);
        // We only spawn top/bottom blocks, ensuring the ground level is always accessible
        obstacles.push({ x, y: 0, w: 60, h: gapY, type: 'block' });
        obstacles.push({ x, y: gapY + 200, w: 60, h: groundY - (gapY + 200), type: 'block' });
      }
    }

    function loop() {
      if (!gameRunning) return;
      frameCount++;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw Background & Ground
      ctx.fillStyle = '#1a1a2e'; ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#2c5aa0'; ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
      ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 4;
      ctx.beginPath(); ctx.moveTo(0, groundY); ctx.lineTo(canvas.width, groundY); ctx.stroke();

      // Mode Physics
      if (gameMode === 'cube') {
        player.velocityY += 0.8;
        player.y += player.velocityY;
        if (player.y >= groundY - player.height) {
          player.y = groundY - player.height; player.velocityY = 0; player.jumping = false;
          player.rotation = 0;
        } else { player.rotation += 0.15; }
      } else if (gameMode === 'ship') {
        player.velocityY += isHoldingJump ? -0.8 : 0.8;
        player.velocityY = Math.max(-8, Math.min(8, player.velocityY));
        player.y += player.velocityY;
        if (player.y > groundY - player.height) player.y = groundY - player.height;
        if (player.y < 0) player.y = 0;
        player.rotation = player.velocityY * 0.1;
      }

      if (frameCount % 80 === 0) spawnObstacle();
      if (frameCount % 500 === 0) {
        const nextMode = gameMode === 'cube' ? 'ship' : 'cube';
        obstacles.push({ x: canvas.width + 100, y: 0, w: 80, h: groundY, type: 'portal', to: nextMode });
      }

      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        o.x -= gameSpeed;

        if (o.type === 'portal') {
          ctx.fillStyle = 'rgba(255, 0, 255, 0.5)';
          ctx.fillRect(o.x, o.y, o.w, o.h);
        } else if (o.type === 'spike') {
          ctx.fillStyle = '#ff4d4d';
          ctx.beginPath(); ctx.moveTo(o.x, o.y + o.h); ctx.lineTo(o.x + o.w, o.y + o.h); ctx.lineTo(o.x + o.w/2, o.y); ctx.fill();
        } else {
          ctx.fillStyle = '#f093fb'; ctx.fillRect(o.x, o.y, o.w, o.h);
        }

        // Collision
        if (player.x < o.x + o.w && player.x + player.width > o.x && player.y < o.y + o.h && player.y + player.height > o.y) {
          if (o.type === 'portal') {
            gameMode = o.to;
            gameModeDisplay.textContent = gameMode.toUpperCase();
            // CLEAR IMPOSSIBLE OBSTACLES: Remove all airborne blocks immediately so the Cube doesn't hit a "ship ceiling"
            obstacles.length = 0; 
          } else {
            gameOver();
          }
        }
        if (o.x < -100) { obstacles.splice(i, 1); score += 10; }
      }

      // Draw Player
      ctx.save();
      ctx.translate(player.x + 20, player.y + 20);
      ctx.rotate(player.rotation);
      ctx.fillStyle = '#43e97b'; ctx.fillRect(-20, -20, 40, 40);
      ctx.restore();

      scoreDisplay.textContent = `Score: ${score}`;
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameRunning = false;
      gameOverScreen.classList.add('show');
      finalScoreDisplay.textContent = `Final Score: ${score}`;
    }

    window.addEventListener('keydown', (e) => { if (e.code === 'Space') { isHoldingJump = true; if (gameMode === 'cube' && !player.jumping) { player.velocityY = -15; player.jumping = true; } } });
    window.addEventListener('keyup', (e) => { if (e.code === 'Space') isHoldingJump = false; });
    startButton.addEventListener('click', startGame);
    restartButton.addEventListener('click', startGame);
  </script>
 </body>
</html>
