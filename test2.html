<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Geometry Dash Neon BETA</title>
  <script src="/_sdk/element_sdk.js"></script>
  <style>
    body {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: 'Arial Black', Arial, sans-serif;
    }

    html, body, #game-container {
      height: 100%;
      width: 100%;
    }

    #game-container {
      position: relative;
      background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1e 100%);
      overflow: hidden;
    }

    #game-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #menu-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, #1e90ff 0%, #4169e1 100%);
      z-index: 10;
      overflow: hidden;
    }

    #menu-screen.hidden {
      display: none;
    }

    .menu-background-pattern {
      position: absolute;
      width: 100%;
      height: 100%;
      opacity: 0.1;
      background-image: 
        repeating-linear-gradient(90deg, transparent, transparent 50px, #00ffff 50px, #00ffff 52px),
        repeating-linear-gradient(0deg, transparent, transparent 50px, #00ffff 50px, #00ffff 52px);
    }

    .menu-floor {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 120px;
      background: linear-gradient(180deg, #2c5aa0 0%, #1e3a5f 100%);
      border-top: 4px solid #00ffff;
      box-shadow: 0 -4px 20px rgba(0, 255, 255, 0.3);
    }

    .neon-shapes {
      position: absolute;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    .neon-cube {
      position: absolute;
      width: 60px;
      height: 60px;
      background: linear-gradient(135deg, #00ffff 0%, #ff00ff 100%);
      box-shadow: 0 0 30px #00ffff, 0 0 60px #ff00ff;
      animation: float 6s ease-in-out infinite;
      opacity: 0.3;
      will-change: transform;
    }

    .neon-cube:nth-child(1) { top: 10%; left: 10%; animation-delay: 0s; }
    .neon-cube:nth-child(2) { top: 60%; left: 80%; animation-delay: 2s; transform: rotate(45deg); }
    .neon-cube:nth-child(3) { top: 30%; left: 70%; animation-delay: 4s; width: 40px; height: 40px; }

    .drifting-cube {
      position: fixed;
      bottom: 130px;
      width: 50px;
      height: 50px;
      background: linear-gradient(135deg, #00ff00 0%, #00cc00 100%);
      border: 2px solid #ffffff;
      box-shadow: 0 0 20px #00ff00, 0 4px 10px rgba(0, 0, 0, 0.5);
      cursor: pointer;
      transition: opacity 0.1s;
      z-index: 1;
      pointer-events: auto;
      left: -60px;
    }

    .drifting-cube.animating {
      animation: driftCube 8s linear infinite, rotateCube 2s linear infinite;
      will-change: transform, left;
    }

    @keyframes driftCube {
      0% { left: -60px; }
      100% { left: 100%; }
    }

    @keyframes rotateCube {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .explosion-particle {
      position: absolute;
      width: 8px;
      height: 8px;
      background: #00ff00;
      border-radius: 50%;
      pointer-events: none;
      box-shadow: 0 0 10px #00ff00;
    }

    @keyframes explode {
      0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
      }
      100% {
        transform: translate(var(--tx), var(--ty)) scale(0);
        opacity: 0;
      }
    }

    @keyframes float {
      0%, 100% { transform: translateY(0) rotate(0deg); }
      50% { transform: translateY(-30px) rotate(180deg); }
    }

    #game-title {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      z-index: 2;
      animation: titleFloat 3s ease-in-out infinite;
      will-change: transform;
    }

    .title-line {
      font-size: 96px;
      color: #00ff00;
      text-shadow: 
        0 0 20px #00ff00,
        0 0 40px #00cc00,
        2px 2px 4px rgba(0, 0, 0, 0.8);
      animation: neonPulse 2s ease-in-out infinite;
      letter-spacing: 4px;
      font-weight: 900;
      margin: 0;
      line-height: 1;
    }

    @keyframes neonPulse {
      0%, 100% { 
        text-shadow: 
          0 0 20px #00ff00,
          0 0 40px #00cc00,
          2px 2px 4px rgba(0, 0, 0, 0.8);
      }
      50% { 
        text-shadow: 
          0 0 30px #00ff00,
          0 0 60px #00cc00,
          2px 2px 4px rgba(0, 0, 0, 0.8);
      }
    }

    @keyframes titleFloat {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-15px); }
    }

    .menu-buttons {
      display: flex;
      flex-direction: column;
      gap: 20px;
      z-index: 200;
      margin-top: 40px;
    }

    #start-button {
      padding: 20px 80px;
      font-size: 36px;
      font-weight: bold;
      color: #ffffff;
      background: linear-gradient(135deg, #00ffff 0%, #ff00ff 100%);
      border: 3px solid #00ffff;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 
        0 0 20px #00ffff,
        0 8px 20px rgba(0, 0, 0, 0.5);
      transition: all 0.3s;
      position: relative;
      overflow: hidden;
      will-change: transform;
    }

    #start-button:hover {
      transform: translateY(-4px) scale(1.05);
      box-shadow: 0 0 30px #00ffff;
    }

    .menu-subtitle {
      color: #ff00ff;
      font-size: 32px;
      text-shadow: 0 0 10px #ff00ff;
      margin-top: 10px;
      margin-bottom: 40px;
      letter-spacing: 12px;
      animation: subtitlePulse 3s ease-in-out infinite;
      z-index: 2;
      font-weight: 900;
    }

    @keyframes subtitlePulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }

    #hud {
      position: absolute;
      top: 20px;
      left: 20px;
      color: #ffffff;
      font-size: 24px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
      z-index: 5;
    }

    #game-mode-display {
      position: absolute;
      top: 20px;
      right: 20px;
      color: #ffffff;
      font-size: 28px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
      z-index: 5;
      padding: 10px 20px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      border: 2px solid #00ffff;
    }

    #game-over-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.85);
      z-index: 100;
    }

    #game-over-screen.show {
      display: flex;
    }

    #game-over-title {
      font-size: 64px;
      color: #f5576c;
      margin-bottom: 20px;
    }

    #restart-button {
      padding: 16px 48px;
      font-size: 28px;
      color: #ffffff;
      background: #43e97b;
      border: none;
      border-radius: 40px;
      cursor: pointer;
    }

    #instructions {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: #ffffff;
      font-size: 20px;
      z-index: 5;
    }
  </style>
 </head>
 <body>
  <div id="game-container">
   <canvas id="game-canvas"></canvas>
   
   <div id="menu-screen">
    <div class="menu-background-pattern"></div>
    <div class="neon-shapes">
     <div class="neon-cube"></div>
     <div class="neon-cube"></div>
     <div class="neon-cube"></div>
    </div>
    <div class="menu-floor"></div>
    <div class="drifting-cube" id="drifting-cube"></div>
    <h1 id="game-title">
     <div class="title-line">GEOMETRY</div>
     <div class="title-line">DASH</div>
    </h1>
    <div class="menu-subtitle">NEON EDITION</div>
    <div class="menu-buttons">
        <button id="start-button">PLAY</button>
    </div>
   </div>

   <div id="hud">
    <div id="score">Score: 0</div>
    <div id="distance">Distance: 0m</div>
   </div>
   <div id="game-mode-display">CUBE</div>
   <div id="instructions">Press SPACE or CLICK to jump</div>
   <div id="game-over-screen">
    <h2 id="game-over-title">Game Over!</h2>
    <p id="final-score" style="color:white; font-size: 24px;">Final Score: 0</p>
    <button id="restart-button">Play Again</button>
   </div>
  </div>

  <script>
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const menuScreen = document.getElementById('menu-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const startButton = document.getElementById('start-button');
    const restartButton = document.getElementById('restart-button');
    const scoreDisplay = document.getElementById('score');
    const distanceDisplay = document.getElementById('distance');
    const finalScoreDisplay = document.getElementById('final-score');
    const driftingCube = document.getElementById('drifting-cube');
    const gameModeDisplay = document.getElementById('game-mode-display');

    // CONFIG - FIXED SPEED FOR SMOOTHNESS
    const GAME_SPEED = 7; 
    const GRAVITY = 0.8;
    const JUMP_FORCE = -15;

    let gameRunning = false;
    let score = 0;
    let gameMode = 'cube';
    let groundY;
    let frameCount = 0;
    let isHoldingJump = false;
    const obstacles = [];
    const particles = [];

    // DRIFTING CUBE ANIMATION
    driftingCube.classList.add('animating');
    driftingCube.addEventListener('click', explodeCube);

    function explodeCube() {
      const rect = driftingCube.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      driftingCube.style.opacity = '0';
      for (let i = 0; i < 15; i++) {
        const p = document.createElement('div');
        p.className = 'explosion-particle';
        p.style.left = centerX + 'px'; p.style.top = centerY + 'px';
        const angle = Math.random() * Math.PI * 2;
        const dist = 50 + Math.random() * 50;
        p.style.setProperty('--tx', Math.cos(angle) * dist + 'px');
        p.style.setProperty('--ty', Math.sin(angle) * dist + 'px');
        p.style.animation = 'explode 0.6s forwards';
        document.body.appendChild(p);
        setTimeout(() => p.remove(), 600);
      }
      setTimeout(() => driftingCube.style.opacity = '1', 1000);
    }

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      groundY = canvas.height - 100;
    }
    window.addEventListener('resize', resize);
    resize();

    const player = {
      x: 150, y: 0, width: 40, height: 40,
      velocityY: 0, rotation: 0, jumping: false,
      ballFlipped: false
    };

    function startGame() {
      menuScreen.classList.add('hidden');
      gameOverScreen.classList.remove('show');
      gameRunning = true;
      score = 0;
      frameCount = 0;
      gameMode = 'cube';
      gameModeDisplay.textContent = 'CUBE';
      obstacles.length = 0;
      particles.length = 0;
      player.y = groundY - player.height;
      player.velocityY = 0;
      player.rotation = 0;
      player.jumping = false;
      player.ballFlipped = false;
      requestAnimationFrame(loop);
    }

    function spawnObstacle() {
      const x = canvas.width + 100;
      const rand = Math.random();

      // THE "2 BLOCKS + SPIKE" PATTERN (ONLY ONE THAT HAS ORBS)
      if (rand < 0.2) {
        // Block 1 (bottom)
        obstacles.push({ x, y: groundY - 40, w: 40, h: 40, type: 'block' });
        // Block 2 (middle)
        obstacles.push({ x, y: groundY - 80, w: 40, h: 40, type: 'block' });
        // Spike (top)
        obstacles.push({ x, y: groundY - 120, w: 40, h: 40, type: 'spike' });
        // Orb (Required for jump)
        obstacles.push({ x: x - 80, y: groundY - 140, w: 40, h: 40, type: 'orb', active: true });
      } 
      else if (rand < 0.5) {
        obstacles.push({ x, y: groundY - 50, w: 30, h: 50, type: 'spike' });
      } 
      else {
        obstacles.push({ x, y: groundY - 40, w: 40, h: 40, type: 'block' });
      }
    }

    function spawnPortal() {
      const modes = ['ship', 'ball', 'cube'];
      const next = modes.filter(m => m !== gameMode)[Math.floor(Math.random() * (modes.length-1))];
      obstacles.push({
        x: canvas.width + 100, y: 0, w: 60, h: groundY, 
        type: 'portal', to: next
      });
    }

    function loop() {
      if (!gameRunning) return;
      frameCount++;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // BG & Ground
      ctx.fillStyle = '#1a1a2e'; ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#2c5aa0'; ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
      ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 4;
      ctx.beginPath(); ctx.moveTo(0, groundY); ctx.lineTo(canvas.width, groundY); ctx.stroke();

      // Player Physics
      if (gameMode === 'cube') {
        player.velocityY += GRAVITY;
        player.y += player.velocityY;
        if (player.y >= groundY - player.height) {
          player.y = groundY - player.height;
          player.velocityY = 0;
          player.jumping = false;
          player.rotation = Math.round(player.rotation / (Math.PI/2)) * (Math.PI/2);
        } else { player.rotation += 0.15; }
      } else if (gameMode === 'ball') {
        player.velocityY += player.ballFlipped ? -GRAVITY : GRAVITY;
        player.y += player.velocityY;
        if (player.y >= groundY - player.height) { player.y = groundY - player.height; player.velocityY = 0; }
        if (player.y <= 0) { player.y = 0; player.velocityY = 0; }
        player.rotation += 0.2;
      } else if (gameMode === 'ship') {
        player.velocityY += isHoldingJump ? -0.6 : 0.5;
        player.velocityY = Math.max(-7, Math.min(7, player.velocityY));
        player.y += player.velocityY;
        if (player.y > groundY - player.height) player.y = groundY - player.height;
        if (player.y < 0) player.y = 0;
        player.rotation = player.velocityY * 0.1;
      }

      // Spawning - Constant interval for zero loading issues
      if (frameCount % 80 === 0) spawnObstacle();
      if (frameCount % 450 === 0) spawnPortal();

      // Obstacle Logic
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        o.x -= GAME_SPEED;

        if (o.type === 'portal') {
          // Stretch across whole part
          let g = ctx.createLinearGradient(o.x, 0, o.x + o.w, 0);
          g.addColorStop(0, 'rgba(255, 0, 255, 0.1)');
          g.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
          g.addColorStop(1, 'rgba(255, 0, 255, 0.1)');
          ctx.fillStyle = g;
          ctx.fillRect(o.x, 0, o.w, groundY);
          ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 3;
          ctx.strokeRect(o.x, 0, o.w, groundY);
        } else if (o.type === 'orb') {
          ctx.fillStyle = o.active ? '#ffff00' : 'rgba(255,255,0,0.2)';
          ctx.beginPath(); ctx.arc(o.x + 20, o.y + 20, 15, 0, Math.PI*2); ctx.fill();
        } else if (o.type === 'spike') {
          ctx.fillStyle = '#ff4d4d';
          ctx.beginPath(); ctx.moveTo(o.x, o.y+o.h); ctx.lineTo(o.x+o.w, o.y+o.h); ctx.lineTo(o.x+o.w/2, o.y); ctx.fill();
        } else {
          ctx.fillStyle = '#f093fb'; ctx.fillRect(o.x, o.y, o.w, o.h);
          ctx.strokeStyle = '#fff'; ctx.strokeRect(o.x, o.y, o.w, o.h);
        }

        // Collision
        if (player.x < o.x + o.w && player.x + player.width > o.x && player.y < o.y + o.h && player.y + player.height > o.y) {
          if (o.type === 'portal') {
            gameMode = o.to; gameModeDisplay.textContent = gameMode.toUpperCase();
            obstacles.splice(i, 1);
          } else if (o.type === 'orb') { /* handled in input */ }
          else {
            gameRunning = false;
            gameOverScreen.classList.add('show');
            finalScoreDisplay.textContent = `Final Score: ${score}`;
          }
        }

        if (o.x < -100) { obstacles.splice(i, 1); score += 5; }
      }

      // Draw Player
      ctx.save();
      ctx.translate(player.x + 20, player.y + 20);
      ctx.rotate(player.rotation);
      ctx.fillStyle = '#43e97b';
      if (gameMode === 'ship') {
          ctx.beginPath(); ctx.ellipse(0, 0, 25, 15, 0, 0, Math.PI*2); ctx.fill();
      } else {
          ctx.fillRect(-20, -20, 40, 40);
          ctx.strokeStyle = '#000'; ctx.strokeRect(-20, -20, 40, 40);
      }
      ctx.restore();

      scoreDisplay.textContent = `Score: ${score}`;
      distanceDisplay.textContent = `Distance: ${Math.floor(frameCount/10)}m`;
      requestAnimationFrame(loop);
    }

    function jump() {
      if (!gameRunning) return;
      
      // Orb check
      for (let o of obstacles) {
        if (o.type === 'orb' && o.active) {
            const dx = (player.x+20) - (o.x+20); const dy = (player.y+20) - (o.y+20);
            if (Math.sqrt(dx*dx + dy*dy) < 70) {
                player.velocityY = JUMP_FORCE; o.active = false; player.jumping = true;
                return;
            }
        }
      }

      if (gameMode === 'cube' && !player.jumping) {
        player.velocityY = JUMP_FORCE; player.jumping = true;
      } else if (gameMode === 'ball') {
        player.ballFlipped = !player.ballFlipped;
      }
    }

    window.addEventListener('keydown', (e) => { if (e.code === 'Space') { isHoldingJump = true; jump(); } });
    window.addEventListener('keyup', (e) => { if (e.code === 'Space') isHoldingJump = false; });
    canvas.addEventListener('mousedown', () => { isHoldingJump = true; jump(); });
    canvas.addEventListener('mouseup', () => isHoldingJump = false);
    startButton.addEventListener('click', startGame);
    restartButton.addEventListener('click', startGame);
  </script>
 </body>
</html>
